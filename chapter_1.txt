1. See c1.py for addition, and the outline for multiplication.

2-4. Shrink alphabet, reduce tapes, and unidirectional tape: skipping explicit TM construction.

5. 
We can construct an oblivious TM M' such that L(M)=L(M') using a technique similar to that in the proof of Claim 1.6. 

Observe that (1) after n steps, M's tape heads will all be in the position range [-n, n], and (2) since M runs in time O(T(n)), there exists some constant k such that for every input n, M runs n fewer than k*T(n) steps. 

First, add two additional work tapes T_1 and T_2. The first thing M' does is count the length of the input and write it to T_1. Next, write k*T(n) to T_2. Since T is time-constructible, and we have the value of 'n' on T_1, this takes time at most T(n). 

Next, we simulate the execute of M in an oblivious way. We simulate each step i of M's execution as follows:
- Start every head t position -i. Move it right to position +i, finding the tape-head-location marker along the way (See Claim 1.6). We note the tapes's movement, writes, and state transition and then return to -(i+1) to begin the next step. If a tape's head is to move right, do so on the right pass, otherwise remember and when we see the marker on the way back, move it at that time. The write and state change can be made on the first pass. 
- Simultaneously, decrement the value on T_2.

When T_2 is 0, halt.

The proof of language equality is essentially the same as in Claim 1.6, and obliviousness is apparent. Waiting k*T(n) simulated steps to halt guarantees that all machines of this input length would have halted by then.

Time anlaysis:
a. Writing T_1, incrementing one-by-one, takes time n*log(n). (For each symbol in the input, we may have to manipulate up to log(n) inputs of the length-so-far's binary representation to increment the value.)
b. Writing T_2 takes time T(n), by the definition of time-constructible
c. Each simulation step, the tapes move up to O(T(n)) steps. Keeping track of -i and i can be done on another tape that simply counts in unary, with the head moving across it to count out the correct distance.
d. Decrementing T_2 takes O(log(k*T(n))) = O(log(T(n))) steps
e. Multiplying c+d by the O(T(n)) "simulated steps" gets us O(T(n))*O(T(n) + log(T(n))) = O(T(n)*T(n) + log(T(n))*T(n)), and since and log(T(n)) < T(n), this simulation runs in O(T(n)**2)

It remains to show that this simulation can be done in as few as 2 tapes. To do this, we interleave all tapes other than the input tape in the standard way. 
- Writing T_1 is only a constant factor slower.
- Similarly with writing T_2, since these are performed sequentially with no other non-input tapes active.
- Each simulation step is also only a constant-factor slower, since we can run over all the interleaved tapes at once, and the T_2 decrement is performed sequentially afterward. 

6. Use a similar construction to 5 above, with T_1, T_2, and decrementing T_2 for each step of the simulation. However, we (a) forget about doing it only 2 tapes, and (b) simulate each step in a different way.
Instead of simulating each head by marking and moving obliviously, we adapt the construction from the proof of Theorem 1.9. Every 2**i steps, we perform a left shift at index i followed by a right shift at index i.

7. Map the plane to the linear tape by using a spiral. Since each 2-D move at worst moves to an adjacent turn of the spiral, and the circumfurence of the turn we're on at at step n is O(n), we have to move at most n steps to get to the head's next location. We can use a scratch tape to record the destination address and compare against it (O(log(n))). Thus O(T(n)*n).

8. First copy i to a scratch tape. Then, with the input head positioned at the start of x, decrement i until it's 0. This takes i*log(i) steps. At each one, move the input head right. Output the final result, or 0 if x runs out before we've reached 0. That's polynomial in the input time, so it's in P.

9. We store all of the "RAM" on a sequential tape. In the execution of our original machine M, it can write to the RAM at most O(T(n)) times. Therefore, our simulated RAM in M' contains at most O(T(n)) elements. We store these elements as (position, value) pairs separated by a special marker. In M', when we move to state q_access, move the simulated-RAM tape head to the start position, then move it right until the (position) matches i, and then take the appropriate action on the address tape with the adjacent value. Since the simulated-RAM tape is of length at most T(n), this takes at most T(n) time, being a linear read. Therefore, each step of our modified M' takes time at most T(n), giving a resultant simulation time of T(n)**2.

10. We assume the program starts at the first line and i is initially 0. This programming language maps quite directly to a Turing Machine. Assign a state to each line of the program. The variable i is the position of the tape head. Every label could do one of two things, depending on whether the tape matches \sigma: continue in that block, or (assuming) skip to the next label. This is represented in the TM's transition table as two obvious transitions, to either the next line or the next label's line, depending on the input. Commands that "Set" a value correspond to the TM's output, and a "Stay" move. The "Goto" command corresponds to a state transition (to the label's line's state) with no output. The increment and decrement commands corresponding to moving the tape head left and right, again without output. Finally, the "Output" command is equivalent to writing on the TM's output tape and halting. In none of these cases does the TM require more than one step to execute a line of the program, so if the program runs in T(n) then the TM does too.

11. See c1.py.
